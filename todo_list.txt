MINISHELL TODO LIST - Separated Concerns Architecture
=======================================================

🔤 LEXER (TOKENIZER) - "What are the symbols?"
=====================================================
✅ [COMPLETED] Basic token types (WORD, PIPE, REDIRECT_IN, REDIRECT_OUT, APPEND, HEREDOC)
✅ [COMPLETED] Quote handling (single and double quotes) with type differentiation
✅ [COMPLETED] Whitespace skipping
✅ [COMPLETED] Multi-character operators (>>, <<)
✅ [COMPLETED] Error handling for unclosed quotes
✅ [COMPLETED] Arena-based memory management for tokenization

🔧 [TODO] Enhanced error reporting
    - Add line/column tracking for better error messages
    - Add token position information

🔧 [TODO] Wildcard detection
    - Add TOKEN_WILDCARD for * symbol
    - Mark tokens that contain wildcards for later expansion

🌳 PARSER - "What's the command structure?"
==========================================
✅ [COMPLETED] Command structure creation
    - Implement parse_commands() to convert tokens to t_command list
    - Handle simple commands: cmd arg1 arg2
    - Handle pipelines: cmd1 | cmd2 | cmd3
✅ [COMPLETED] Arena-based memory for command tables
    - Command table built using arena allocation
    - Reset between commands for memory efficiency

✅ [COMPLETED] Redirection parsing
    - Parse input redirection: < file
    - Parse output redirection: > file  
    - Parse append redirection: >> file
    - Parse heredoc: << delimiter

🔧 [TODO] Quote removal and variable expansion
    - Remove quotes from WORD tokens that were quoted
    - Preserve literal values inside quotes
    - Expand variables ($VAR) based on quote context
    - Handle special variables: $?, $$, $0
    - Different behavior for single vs double quotes

🔧 [TODO] Syntax validation
    - Check for invalid pipe usage (pipe at start/end, double pipes)
    - Check for invalid redirections (missing filenames)
    - Check for proper command structure

🔧 [TODO] Logical operators parsing
    - Parse && (AND) and || (OR) operators
    - Build command chains with conditional execution

🔧 [TODO] Subshell parsing
    - Parse parentheses for subshell execution: (cmd1; cmd2)
    - Handle nested subshells

🔧 [TODO] Error recovery
    - Provide meaningful syntax error messages
    - Implement error recovery strategies

⚡ EXECUTOR - "How do I run this?"
=================================
🔧 [TODO] Built-in command recognition
    - Implement is_builtin() function
    - Create builtin dispatch table: echo, cd, pwd, export, unset, env, exit

🔧 [TODO] Built-in implementations
    - builtin_echo(): Handle -n flag, multiple arguments
    - builtin_cd(): Handle relative/absolute paths, HOME, OLDPWD
    - builtin_pwd(): Print current working directory
    - builtin_export(): Set environment variables, handle invalid names
    - builtin_unset(): Remove environment variables
    - builtin_env(): Print all environment variables
    - builtin_exit(): Handle exit codes, cleanup

🔧 [TODO] External command execution
    - PATH resolution for commands
    - fork() and execve() for external programs
    - Fr Giang: in pipex exec_cmd, if cmd_av == NULL, just exit but not error, 
    since a command like "cat file | > out.txt" will still create outfile although no command is executed, 
    no error appears in bash and exit code is 0;
    - Handle command not found errors

🔧 [TODO] Pipeline execution
    - Create pipes between commands
    - Handle multiple processes in pipeline
    - Wait for all processes and collect exit codes

🔧 [TODO] Redirection handling
    - Open files for input/output redirection
    - Handle file permission errors
    - Restore original stdin/stdout after redirection

🔧 [TODO] Heredoc implementation
    - Read input until delimiter is found
    - Handle variable expansion in heredoc (if required)
    - Create temporary files or use pipes

🔧 [TODO] Wildcard expansion
    - Use glob() function for * expansion
    - Handle no matches (return literal *)
    - Sort expanded filenames

🔧 [TODO] Logical operators execution
    - Implement && (execute next only if current succeeds)
    - Implement || (execute next only if current fails)
    - Handle short-circuit evaluation

🔧 [TODO] Signal handling
    - Handle Ctrl+C (SIGINT) - interrupt current command
    - Handle Ctrl+\ (SIGQUIT) - ignore in interactive mode
    - Handle Ctrl+D (EOF) - exit shell gracefully

🔧 [TODO] Subshell execution
    - Create child process for subshell
    - Execute commands in isolated environment
    - Return subshell exit status

🔧 [TODO] Error handling
    - Set $? exit status correctly
    - Handle command not found (127)
    - Handle permission denied (126)
    - Handle other execution errors

🛠️ INFRASTRUCTURE & UTILITIES
=============================
✅ [COMPLETED] Memory management
    - Implemented memory arena for efficient allocation
    - Arena-based string functions (ar_strdup, ar_substr, ar_strjoin, ar_split)
    - Auto-extending arena when needed
    - Memory alignment for optimal performance
    - Reset functionality for command-by-command reuse

🔧 [TODO] Environment management
    - Create environment variable manipulation functions
    - Handle environment variable inheritance
    - Implement variable scoping for subshells

🔧 [TODO] History management (bonus)
    - Implement command history storage
    - Add history expansion (!!, !n, !string)
    - Save/load history from file

🔧 [TODO] Job control (bonus)
    - Implement background processes (&)
    - Add job status tracking
    - Implement jobs, fg, bg built-ins

🔧 [TODO] Advanced features (bonus)
    - Command line editing with readline
    - Tab completion for commands/files
    - Prompt customization

🧪 TESTING & VALIDATION
=======================
🔧 [TODO] Unit tests
    - Test tokenizer with various inputs
    - Test parser with complex command structures
    - Test each built-in command individually

🔧 [TODO] Integration tests
    - Test complete command execution flow
    - Test error handling and edge cases
    - Test memory management

🔧 [TODO] Comparison testing
    - Compare behavior with bash
    - Test subject requirements compliance
    - Test bonus features if implemented

📋 CURRENT STATUS
================
✅ Tokenizer complete with arena memory management
✅ Quote handling with type differentiation implemented
✅ Parser base functionality complete with arena memory
✅ Memory arena infrastructure complete and integrated
⏳ Variable expansion - NEXT PRIORITY
⏳ Basic executor - After variable expansion
⏳ Advanced features - Final phase

🎯 NEXT IMMEDIATE STEPS
======================
1. Implement variable expansion in the parser with quote context awareness
2. Add syntax validation during parsing
3. Implement simple command execution (no pipes/redirections first)
4. Add built-in command recognition and basic built-ins (echo, pwd, env)
5. Gradually add complexity (pipes, redirections, etc.)

📝 NOTES
========
- Follow 42 Norm: functions ≤25 lines, ≤80 chars per line
- Add comprehensive comments for learning
- Test each component thoroughly before moving to next
- Keep clean separation between lexer/parser/executor
- Built-ins are recognized at EXECUTION time, not parsing time
- All command names are WORD tokens regardless of type (built-in vs external)

🚀 Remember: "Make it work, make it right, make it fast!"
