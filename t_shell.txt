//struct for the shell
typedef struct s_shell
{
    // Environment management
    char        **env_copy;         // Our own copy of environment variables
    t_arena     *env_arena;         // Arena for environment strings
    
    // Command execution state
    int         exit_status;        // Last command exit status
    int         interactive;        // 1 if interactive mode, 0 if script
    
    // Memory management
    t_arena     *main_arena;        // Arena for command parsing/execution
    
    // Process management
    pid_t       *child_pids;        // Array of background process PIDs
    int         child_count;        // Number of active background processes
    int         max_children;       // Max capacity for child_pids array
    
    // Signal handling state
    int         interrupted;        // Set to 1 when SIGINT received
    int         should_exit;        // Set to 1 when exit requested
    
    // Shell options (for future expansion)
    int         verbose;            // Verbose mode for debugging
    char        *prompt;            // Custom prompt string
} t_shell;

#include "minishell.h"
#include <unistd.h>
#include <signal.h>

/*
** init_shell - Initialize shell structure with environment copy
**
** DESCRIPTION:
**   Creates and initializes a new shell instance with:
**   - Environment copy for safe modification
**   - Memory arenas for efficient allocation
**   - Interactive mode detection
**   - Signal handling setup
**
** PARAMETERS:
**   envp - Original environment from main()
**
** RETURN VALUE:
**   Returns initialized shell structure or NULL on failure
*/
t_shell *init_shell(char **envp)
{
    t_shell *shell;
    
    // Allocate shell structure
    shell = malloc(sizeof(t_shell));
    if (!shell)
        return (NULL);
    
    // Initialize memory arenas
    shell->main_arena = arena_init();
    shell->env_arena = arena_init();
    if (!shell->main_arena || !shell->env_arena)
    {
        cleanup_shell(shell);
        return (NULL);
    }
    
    // Copy environment variables
    shell->env_copy = copy_environment(shell->env_arena, envp);
    if (!shell->env_copy)
    {
        cleanup_shell(shell);
        return (NULL);
    }
    
    // Initialize execution state
    shell->exit_status = 0;
    shell->interactive = isatty(STDIN_FILENO);
    
    // Initialize process management
    shell->max_children = 100;  // Initial capacity
    shell->child_pids = arena_alloc(shell->env_arena, 
                                   sizeof(pid_t) * shell->max_children);
    shell->child_count = 0;
    
    // Initialize signal handling state
    shell->interrupted = 0;
    shell->should_exit = 0;
    
    // Initialize shell options
    shell->verbose = 0;
    shell->prompt = arena_strdup(shell->env_arena, "minishell$ ");
    
    // Setup signal handlers
    setup_signal_handlers(shell);
    
    return (shell);
}

/*
** copy_environment - Create a copy of environment variables
**
** DESCRIPTION:
**   Creates an independent copy of environment variables in arena memory.
**   This allows safe modification without affecting parent shell.
**
** PARAMETERS:
**   arena - Arena for memory allocation
**   envp  - Original environment array
**
** RETURN VALUE:
**   Returns new environment array or NULL on failure
*/
char **copy_environment(t_arena *arena, char **envp)
{
    int count = 0;
    char **env_copy;
    
    if (!envp)
        return (NULL);
    
    // Count environment variables
    while (envp[count])
        count++;
    
    // Allocate array (count + 1 for NULL terminator)
    env_copy = arena_alloc(arena, sizeof(char *) * (count + 1));
    if (!env_copy)
        return (NULL);
    
    // Copy each environment variable
    for (int i = 0; i < count; i++)
    {
        env_copy[i] = arena_strdup(arena, envp[i]);
        if (!env_copy[i])
            return (NULL);
    }
    env_copy[count] = NULL;
    
    return (env_copy);
}

/*
** cleanup_shell - Clean up shell resources
**
** DESCRIPTION:
**   Frees all resources associated with the shell.
**   Should be called before program termination.
**
** PARAMETERS:
**   shell - Shell structure to clean up
**
** RETURN VALUE:
**   None
*/
void cleanup_shell(t_shell *shell)
{
    if (!shell)
        return;
    
    // Clean up background processes
    cleanup_background_processes(shell);
    
    // Free arenas (this frees all arena-allocated memory)
    if (shell->env_arena)
        free_arena(shell->env_arena);
    if (shell->main_arena)
        free_arena(shell->main_arena);
    
    // Free shell structure itself
    free(shell);
}

/*
** setup_signal_handlers - Setup signal handling for shell
**
** DESCRIPTION:
**   Configures signal handlers for interactive shell behavior.
**
** PARAMETERS:
**   shell - Shell structure for signal context
**
** RETURN VALUE:
**   None
*/
void setup_signal_handlers(t_shell *shell)
{
    // TODO: Implement signal handling
    // signal(SIGINT, handle_sigint);
    // signal(SIGQUIT, SIG_IGN);
    (void)shell; // Suppress unused parameter warning for now
}

/*
** cleanup_background_processes - Clean up background processes
**
** DESCRIPTION:
**   Waits for or kills any remaining background processes.
**
** PARAMETERS:
**   shell - Shell structure containing process list
**
** RETURN VALUE:
**   None
*/
void cleanup_background_processes(t_shell *shell)
{
    if (!shell || !shell->child_pids)
        return;
    
    for (int i = 0; i < shell->child_count; i++)
    {
        if (shell->child_pids[i] > 0)
        {
            // Try to wait for process (non-blocking)
            int status;
            if (waitpid(shell->child_pids[i], &status, WNOHANG) == 0)
            {
                // Process still running, send SIGTERM
                kill(shell->child_pids[i], SIGTERM);
                waitpid(shell->child_pids[i], &status, 0);
            }
        }
    }
    shell->child_count = 0;
}



//update the functions signetures
// Change your current functions to use t_shell instead of char **env

int exe_builtin_with_redirections(t_cmd *cmd, t_shell *shell)
{
    char *cmd_name = cmd->cmd_av[0];
    
    // Commands that must NOT fork
    if (ft_strcmp(cmd_name, "cd") == 0 || ft_strcmp(cmd_name, "exit") == 0 ||
        ft_strcmp(cmd_name, "export") == 0 || ft_strcmp(cmd_name, "unset") == 0)
    {
        if (cmd->redirections)
        {
            ft_printf("minishell: %s: redirection not supported for this built-in\n", cmd_name);
            return (1);
        }
        return (exe_builtin(cmd, shell));
    }
    
    // Rest of function...
}

int exe_builtin(t_cmd *cmd, t_shell *shell)
{
    char *cmd_name = cmd->cmd_av[0];
    
    if (ft_strcmp(cmd_name, "cd") == 0)
        return (builtin_cd(cmd, shell));
    else if (ft_strcmp(cmd_name, "echo") == 0)
        return (builtin_echo(cmd));
    else if (ft_strcmp(cmd_name, "pwd") == 0)
        return (builtin_pwd());
    else if (ft_strcmp(cmd_name, "env") == 0)
        return (builtin_env(shell));
    else if (ft_strcmp(cmd_name, "export") == 0)
        return (builtin_export(cmd, shell));
    else if (ft_strcmp(cmd_name, "unset") == 0)
        return (builtin_unset(cmd, shell));
    else if (ft_strcmp(cmd_name, "exit") == 0)
        return (builtin_exit(cmd, shell));
    
    return (1);
}

int exe_external_cmd(t_cmd *cmd, t_shell *shell)
{
    char *executable_path = find_executable(shell->main_arena, cmd->cmd_av[0], shell->env_copy);
    
    // Rest of function using shell->env_copy instead of env parameter...
}

//then at the end we need to update the main function to use the new utills
int main(int argc, char **argv, char **envp)
{
    t_shell *shell;
    char *input;
    t_cmd_table *cmd_table;
    
    // Initialize shell with environment copy
    shell = init_shell(envp);
    if (!shell)
    {
        ft_printf("minishell: failed to initialize shell\n");
        return (1);
    }
    
    // Main shell loop
    while (!shell->should_exit)
    {
        // Show prompt only in interactive mode
        if (shell->interactive)
            input = readline(shell->prompt);
        else
            input = get_next_line(STDIN_FILENO);
            
        if (!input)
            break;
            
        // Parse and execute command
        cmd_table = parse_input(shell->main_arena, input);
        if (cmd_table)
        {
            shell->exit_status = exe_cmd(cmd_table, shell);
        }
        
        // Reset arena for next command
        arena_reset(shell->main_arena);
        free(input);
    }
    
    int exit_code = shell->exit_status;
    cleanup_shell(shell);
    return (exit_code);
}
